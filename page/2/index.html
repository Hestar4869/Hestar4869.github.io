<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hestar&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hestar&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hestar">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hestar's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hestar's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">存储管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-30 16:40:59" itemprop="dateCreated datePublished" datetime="2022-03-30T16:40:59+08:00">2022-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-31 09:24:15" itemprop="dateModified" datetime="2022-03-31T09:24:15+08:00">2022-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h2><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p>把程序中的地址（虚拟地址&#x2F;逻辑地址）变成内存的真实地址（实地址）的过程<br>地址重定位，地址重映射</p>
<h4 id="固定地址映射"><a href="#固定地址映射" class="headerlink" title="固定地址映射"></a>固定地址映射</h4><ul>
<li>固定地址映射：<strong>编程或编译时</strong>确定逻辑地址和物理地址映射关系。</li>
</ul>
<p>特点：程序<strong>加载时</strong>必须放在内存中，容易产生冲突，运行失败</p>
<h4 id="静态地址映射"><a href="#静态地址映射" class="headerlink" title="静态地址映射"></a>静态地址映射</h4><p>定义：程序<strong>装入时</strong>有操作系统完成逻辑地址到物理地址的映射</p>
<p>基本概念：</p>
<ul>
<li>逻辑地址 VA（virtual addr）</li>
<li>装入基址 BA （base addr）</li>
<li>物理地址 MA （Memory addr）<br> MA &#x3D; BA + VA</li>
</ul>
<p>特点：</p>
<ul>
<li>程序运行之前确定映射关系</li>
<li>程序<strong>装入后不能移动</strong></li>
<li><ul>
<li>如果移动必须放回原来位置</li>
</ul>
</li>
<li>程序占用<strong>连续的</strong>内存空间</li>
</ul>
<h4 id="动态地址映射"><a href="#动态地址映射" class="headerlink" title="动态地址映射"></a>动态地址映射</h4><p>定义：在程序执行过程中把逻辑地址转换为物理地址。例如：MOV AX，[500]; 访问500单元时。映射过程与静态地址映射相同</p>
<p>特点：</p>
<ul>
<li>程序占用的内存空间可动态变化，要求即使更新基址</li>
<li>程序不要求占用连续的内存空间，每段放置基址BA系统应该知道</li>
<li>便于多个进程共享代码</li>
</ul>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h3 id="内存分配功能"><a href="#内存分配功能" class="headerlink" title="内存分配功能"></a>内存分配功能</h3><p>为程序运行分配足够的内存空间<br>需要解决的问题：</p>
<ul>
<li>放置策略：程序调入内存时将其放置在哪个内存区</li>
<li>调入策略：何时把药运行的代码和药访问的数据调入内存</li>
<li>淘汰策略：内存空间不够时，腾出空间</li>
</ul>
<h3 id="存储保护功能"><a href="#存储保护功能" class="headerlink" title="存储保护功能"></a>存储保护功能</h3><p>保证在内存中的多道程序只能在给定的存储区域内活动并互不干扰：防止访问越界，防止访问越权</p>
<p>方法：界址寄存器</p>
<ul>
<li>在cpu中设置一对下线寄存器和上限寄存器存放程序在内存中的下限地址和上限地址</li>
</ul>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h3><h4 id="单一区存储管理不分区存储管理"><a href="#单一区存储管理（不分区存储管理）" class="headerlink" title="单一区存储管理（不分区存储管理）"></a>单一区存储管理（不分区存储管理）</h4><p>用户去不分区，完全被一个程序占用</p>
<h4 id="分区存储管理"><a href="#分区存储管理-1" class="headerlink" title="分区存储管理"></a>分区存储管理</h4><ul>
<li>把用户区内存划分为若干大小不等的分区，供不同程序使用</li>
<li>适合单用户单任务系统</li>
</ul>
<p>固定分区：每个分区位置固定，不再改变。系统要维护分区表<br>动态分区：存在内存碎片</p>
<p>下面具体讨论如何在动态分区保证内存碎片合理利用</p>
<h3 id="空闲区表如何排序放置策略"><a href="#空闲区表如何排序——放置策略" class="headerlink" title="空闲区表如何排序——放置策略"></a>空闲区表如何排序——放置策略</h3><p>放置策略（空闲区表排序原则）</p>
<ul>
<li>首次适应算法：按空闲区位置（首址）排序递增排序</li>
<li>：按空闲区位置（首址）递减排序</li>
<li>最佳适应算法：按空闲区大小的递增排序</li>
<li>最坏适应算法：按空闲区大小的递减排序</li>
</ul>
<h3 id="分区的回收"><a href="#分区的回收" class="headerlink" title="分区的回收"></a>分区的回收</h3><p>功能：回收程序释放分区（释放区），登记到空闲区表中，以便再分配</p>
<p>回收算法：</p>
<ul>
<li>要考虑释放区与现有空闲区<strong>是否相邻</strong>？</li>
<li>若释放去与现有空闲区不相邻，则直接插入空闲区表</li>
<li>若释放去与现有空闲区相邻，则于空闲区合并后更新空闲区表</li>
</ul>
<h3 id="内存覆盖技术"><a href="#内存覆盖技术" class="headerlink" title="内存覆盖技术"></a>内存覆盖技术</h3><p>目的：在<strong>较小的</strong>内存空间中运行较大的程序</p>
<p>内存分区：</p>
<ul>
<li>常驻区：被某段单独切固定的占用，可划分为多个</li>
<li>覆盖区：能被多端共用（覆盖），可划分为多个</li>
</ul>
<p>缺点：编程复杂，程序员划分程序模块并确定覆盖关系</p>
<h3 id="内存交换技术"><a href="#内存交换技术" class="headerlink" title="内存交换技术"></a>内存交换技术</h3><p>原理：内存不够时把进程写到磁盘，当进程要运行时重新写回内存</p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>过小的空闲区，难实际利用。内存碎片会降低内存区的利用率。</p>
<blockquote>
<p><strong>动态分区时，最佳适应法最容易产生碎片</strong><br>因为内存反复分配和分隔，容易产生较小的难以利用的内存碎片</p>
</blockquote>
<p>碎片问题的解决：</p>
<ol>
<li>规定门限值：分隔空闲区时，若剩余部分小于门限值，则此空闲区不进行分隔，而是全部分配给用户。（不算多此一举吗？）</li>
<li>内存拼接技术：将所有空闲区集中一起构成一个大的空闲区</li>
<li>解除程序占用<strong>连续内存</strong>才能运行的限制：让程序运行在不连续的内存地址。</li>
</ol>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理-1" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>基本目标：</p>
<ul>
<li>使得大的程序能在较小的内存中运行</li>
<li>使得多个程序能在较小的内存中运行</li>
<li>使得多个程序并发运行时地址不冲突</li>
<li>使得内存利用效率高：无碎片，共享方便</li>
</ul>
<p>实现思路：在程序运行时，只把当前必要的很小一部分代码和数据装入内存中，其余代码和数据需要时再装入。不再运行的代码和数据及时从内存删除。</p>
<p>典型虚拟内存管理方式：</p>
<ul>
<li>页式虚拟存储管理</li>
<li>段式虚拟存储管理</li>
<li>段页式虚拟存储管理</li>
</ul>
<h3 id="页式虚拟内存管理的概念"><a href="#页式虚拟内存管理的概念" class="headerlink" title="页式虚拟内存管理的概念"></a>页式虚拟内存管理的概念</h3><p>概念：把进程空间和内存空间划成等大小的小片</p>
<ul>
<li>进程的小片—— <strong>页</strong>（虚拟页或页面）</li>
<li>内存的小片—— **（物理页）</li>
</ul>
<p>进程装入和使用内存的原则：</p>
<ul>
<li>内存以<strong>页框</strong>为单位分配使用</li>
<li>进程以<strong>页</strong>为单位装入内存</li>
</ul>
<h4 id="页表和页式地址的映射"><a href="#页表和页式地址的映射" class="headerlink" title="页表和页式地址的映射"></a>页表和页式地址的映射</h4><p>虚拟地址（VA）可以分解成<strong>页号</strong>P和<strong>页内偏移</strong>W<br>页号（P）: VA所处页的编号&#x3D;VA&#x2F;页的大小<br>页内偏移：VA在所处页中的偏移&#x3D;VA % 页的大小</p>
<p>页面映射表：记录<strong>页</strong>与<strong>页框</strong>之间的<strong>对应关系</strong></p>
<h3 id="快表技术和页面共享技术"><a href="#快表技术和页面共享技术" class="headerlink" title="快表技术和页面共享技术"></a>快表技术和页面共享技术</h3><h4 id="快表机制cache"><a href="#快表机制（Cache）" class="headerlink" title="快表机制（Cache）"></a>快表机制（Cache）</h4><p>快表概念：</p>
<ul>
<li>慢表：页表放在内存中</li>
<li>快表：页表放在cache中</li>
</ul>
<h4 id="页面共享技术"><a href="#页面共享技术" class="headerlink" title="页面共享技术"></a>页面共享技术</h4><p>页面共享原理：</p>
<ul>
<li>在不同进程的页表中填上<strong>相同的页框号</strong>，多个进程能访问相同的内存空间，从而实现<strong>页面共享</strong>。</li>
<li><strong>共享页面</strong>在内存只有<strong>一份</strong>真实存储，节省内存</li>
</ul>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p><img src="/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/2022-03-30-20-15-30.png" alt="缺页的情况"></p>
<p>扩充有<strong>中断位</strong>和辅存地址的页表</p>
<p>缺页中断：在地址映射过程中，当所要访问的目的页不在内存时，则系统产生异常中断 —— 缺页中断</p>
<h3 id="页面淘汰策略"><a href="#页面淘汰策略" class="headerlink" title="页面淘汰策略"></a>页面淘汰策略</h3><p>淘汰策略：选择淘汰哪一页的规则称为淘汰策略</p>
<p>页面抖动：页面在内存和辅存间频繁交换的现象。“抖动”会导致系统效率下降</p>
<p>好的淘汰策略：具有较低的缺页率，页面抖动较少<br>常用的淘汰算法：</p>
<ul>
<li>最佳算法（OPT算法）:淘汰以后<strong>不再需要</strong>或<strong>最远的将来</strong>才会用到的页面。理论最佳，实际无法实现</li>
<li>先进先出淘汰算法（FIFO算法）：淘汰在<strong>内存中停留时间最长</strong>的页面。</li>
<li>最久未使用淘汰算法（LRU算法）：淘汰<strong>最长时间未被使用</strong>的页面。</li>
<li>最不经常使用算法（LFU算法）：选择到当前时间为止被访问次数最少的页面。</li>
</ul>
<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><p>进程分段：把进程按<strong>逻辑意义</strong>划分位多个段，每段有段名，进程由多段组成</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/Java/Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/Java/Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E5%8C%85/" class="post-title-link" itemprop="url">Java语言核心包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-21 20:05:06" itemprop="dateCreated datePublished" datetime="2022-03-21T20:05:06+08:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-23 20:30:32" itemprop="dateModified" datetime="2022-03-23T20:30:32+08:00">2022-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>488</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="javalang包"><a href="#java-lang包" class="headerlink" title="java.lang包"></a>java.lang包</h2><p>时Java中最基础的核心包，里面包含……</p>
<h3 id="javalangmath"><a href="#Java-lang-Math" class="headerlink" title="Java.lang.Math"></a>Java.lang.Math</h3><h3 id="javalangstring"><a href="#Java-lang-String" class="headerlink" title="Java.lang.String"></a>Java.lang.String</h3><p>直接赋值时，系统为了节省内存，用的是<strong>池机制</strong></p>
<p><strong>如何判断字符串内容是否相等？</strong></p>
<ul>
<li>显然，不能使用 &#x3D;&#x3D; </li>
<li>所以需要使用equals进行判断。</li>
</ul>
<h3 id="javalangstringbuffer类"><a href="#Java-lang-StringBuffer类" class="headerlink" title="Java.lang.StringBuffer类"></a>Java.lang.StringBuffer类</h3><p>负责字符串处理，是自变型字符串，操作之后，自己变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;CSU&quot;</span>;</span><br><span class="line">s1.replace(<span class="string">&quot;CSU&quot;</span>,<span class="string">&quot;中南大学&quot;</span>);<span class="comment">//s1不变</span></span><br><span class="line">StringBuffer s1=<span class="string">&quot;CSU&quot;</span>;</span><br><span class="line">s2.replace(<span class="string">&quot;CSU&quot;</span>,<span class="string">&quot;中南大学&quot;</span>);<span class="comment">//s2为“中南大学”</span></span><br></pre></td></tr></table></figure>

<h2 id="javautil包"><a href="#Java-util包" class="headerlink" title="Java.util包"></a>Java.util包</h2><p>最重要的是：Java集合框架（变长数组）<br>三类：</p>
<ol>
<li><p>List类：一维变长数组，元素有位置，可重复</p>
<ul>
<li>ArrayList：底层用数组存储</li>
<li>LinkedList:底层用链表存储</li>
<li>Vector：实现了多线程的安全</li>
</ul>
</li>
<li><p>Set类：一维变长数组，元素无位置信息，不可重复</p>
</li>
<li><p>Map类：二维变长数组</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">死锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-17 19:24:52 / 修改时间：19:58:11" itemprop="dateCreated datePublished" datetime="2022-03-17T19:24:52+08:00">2022-03-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>386</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h2><p>哲学家就餐问题：五个哲学家围坐在圆桌旁边，有5只筷子。哲学家：思考-学习-吃饭<br>吃法使用两只筷子：</p>
<ul>
<li>拿一双筷子才能吃</li>
<li>每次只能区一只筷子</li>
<li>只取身边的筷子</li>
<li>吃完放下筷子</li>
</ul>
<p><strong>死锁定义</strong>：两个或多个进程无限期的等待永远不会发生的条件的一种系统状态。(结果：每个进程都永远阻塞)</p>
<p>例如：每个哲学家都无限期的等待邻座放下筷子，而邻座没有吃完之前不会放下筷子，而邻座缺一只筷子永远都无法吃完。</p>
<h2 id="死锁的起因"><a href="#死锁的起因" class="headerlink" title="死锁的起因"></a>死锁的起因</h2><ul>
<li><strong>系统资源有限：</strong>资源数目不足，进程对资源的竞争而产生死锁。</li>
<li><strong>并发进程的推进顺序不当：</strong>进程请求资源或释放资源顺序不当</li>
</ul>
<h2 id="死锁的防范策略"><a href="#死锁的防范策略" class="headerlink" title="死锁的防范策略"></a>死锁的防范策略</h2><p>死锁的必要条件：</p>
<ul>
<li>互斥条件：进程互斥使用资源，资源具有独占性</li>
<li>不剥夺条件：进程在访问完资源前不能被其他进程强行剥夺</li>
<li>部分分配条件：进程边运行边申请资源，临时需要临时分配</li>
<li>环路条件：多个进程构成环路：环中每个进程已占用的资源被前一进程申请，而自己所申请资源又被环中后一进程占用着</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-15 20:07:02" itemprop="dateCreated datePublished" datetime="2022-03-15T20:07:02+08:00">2022-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-17 15:12:47" itemprop="dateModified" datetime="2022-03-17T15:12:47+08:00">2022-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><h3 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h3><p>描述和管理程序的过程——进程</p>
<ul>
<li>进程是程序在某个数据集合上的一次运行活动</li>
<li>数据集合：软硬件环境，多个进程共存&#x2F;共享的环境</li>
</ul>
<p>进程的特征：</p>
<ul>
<li>动态性：</li>
<li>并发性:</li>
<li>异步性：进程按各自速度向前推进</li>
<li>独立性：进程是系统分配资源和调度CPU的单位</li>
</ul>
<p>进程与程序的区别：</p>
<ol>
<li>动态与静态<ul>
<li>进程是动态的：程序的一次执行过程</li>
<li>程序是静态的：一组指令的有序集合</li>
</ul>
</li>
<li>暂存与长存<ul>
<li>进程是暂存的：在内存驻留</li>
<li>程序是长存的：在介质上长期保存</li>
</ul>
</li>
<li>程序和进程的对应<ul>
<li>一个程序可能由多个进程<h3 id="12-进程的状态"><a href="#1-2-进程的状态" class="headerlink" title="1.2 进程的状态"></a>1.2 进程的状态</h3>运行状态（Running）</li>
</ul>
</li>
</ol>
<ul>
<li>进程已经<strong>占有CPU</strong>，在CPU上运行</li>
</ul>
<p>就绪状态（Ready）</p>
<ul>
<li><strong>具备运行条件</strong>但由于无CPU，暂时不能运行</li>
</ul>
<p>阻塞状态（Block）</p>
<ul>
<li>因为<strong>等待某项服务</strong>完成或信号不能运行的状态</li>
<li>如等待：系统调用，IO操作，合作进程信号</li>
</ul>
<p>进程状态的变迁：</p>
<ol>
<li>就绪-&gt;运行：进程调度</li>
<li>运行-&gt;就绪：时间片到，被抢占</li>
<li>运行-&gt;阻塞：请求服务，等待信号</li>
<li>阻塞-&gt;就绪：服务完成；信号到来<br><img src="/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2022-03-15-20-20-01.png" alt="进程状态变迁"></li>
</ol>
<h3 id="13-进程控制块pcb"><a href="#1-3-进程控制块PCB" class="headerlink" title="1.3 进程控制块PCB"></a>1.3 进程控制块PCB</h3><p>进程控制块（Process Control Block PCB）</p>
<ul>
<li>描述进程状态、资源，和与相关进程关系的<strong>数据结构</strong></li>
<li>PCB是进程的标志</li>
<li>创建进程是创建PCB，进程撤销后PCB同时撤销</li>
</ul>
<h2 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2. 进程控制"></a>2. 进程控制</h2><p>进程控制的概念</p>
<ul>
<li><strong>在进程生存全期间，对其全部行为的控制</strong></li>
<li>四个典型的控制行为：创建进程，阻塞进程，撤销进程，唤醒进程</li>
</ul>
<p>原语：</p>
<ul>
<li>由若干指令构成的具有特定功能的函数</li>
<li>具有<strong>原子性</strong>，其操作不可分割<h3 id="21-创建进程"><a href="#2-1-创建进程：" class="headerlink" title="2.1 创建进程："></a>2.1 创建进程：</h3>功能：创建一个具有指定标识PID表示的进程<br>参数：进程标识、优先级、进程起始地址、CPU初始状态、资源清单等。</li>
</ul>
<p>创建进程的过程：</p>
<ul>
<li>出啊构建一个空白的PCB</li>
<li>获得并赋予进程标识符ID</li>
<li>为进程分配空间</li>
<li>初始化PCB</li>
<li>插入相应的进程队列</li>
</ul>
<h3 id="22-撤销进程"><a href="#2-2-撤销进程" class="headerlink" title="2.2 撤销进程"></a>2.2 撤销进程</h3><h3 id="23-阻塞进程"><a href="#2-3-阻塞进程" class="headerlink" title="2.3 阻塞进程"></a>2.3 阻塞进程</h3><h2 id="3-线程tread"><a href="#3-线程（Tread）" class="headerlink" title="3. 线程（Tread）"></a>3. 线程（Tread）</h2><ul>
<li>线程是可由CPU直接运行的实体</li>
<li>一个进程可以创建多个线程</li>
<li>多个线程共享CPU，可以实现并发运行<blockquote>
<p>同时画圆和画方的例子</p>
</blockquote>
</li>
</ul>
<p><strong>单线程程序</strong>：整个进程只有一个线程。Windows程序缺省只有一个线程（主线程，main线程）。<br><strong>多线程程序</strong>：整个进程只有有两个线程。主线程和至少一个用户线程。</p>
<h2 id="4-临界区和锁"><a href="#4-临界区和锁" class="headerlink" title="4. 临界区和锁"></a>4. 临界区和锁</h2><h3 id="41-临界区与临界资源"><a href="#4-1-临界区与临界资源" class="headerlink" title="4.1 临界区与临界资源"></a>4.1 临界区与临界资源</h3><p><strong>临界资源（Critical Resource</strong>）：一次只允许一个进程独占访问（使用的）的资源<br><strong>临界区（Critical Section）</strong>：进程中访问临界资源的程序段</p>
<p>访问特点：</p>
<ul>
<li>具有排他性</li>
<li>并发进程不能同时进入临界区</li>
</ul>
<p><strong>设计临界区访问机制的四个原则</strong>:</p>
<ul>
<li>忙则等待：当临界区忙时，其他进程必须在临界区外等待</li>
<li>空闲让进：当无进程处于临界区时，任何<strong>有权进程</strong>可进入临界区</li>
<li>有限等待：进程进入临界区的请求应在<strong>有限时间</strong>内得到满足</li>
<li><ul>
<li>所以临界区不能设置太多或者太小，应该刚好包括有限资源，以方便其他等待的进程能<strong>尽可能的达到</strong>接近临界区的位置</li>
</ul>
</li>
<li>让权等待：等待进程放弃CPU，让其他进程有机会得到CPU（？）</li>
</ul>
<h3 id="42-锁机制"><a href="#4-2-锁机制" class="headerlink" title="4.2 锁机制"></a>4.2 锁机制</h3><p>基本原理：</p>
<ul>
<li>设置一个<strong>标志</strong>S;</li>
<li><ul>
<li>表明临界资源<strong>可用</strong>还是<strong>不可用</strong></li>
</ul>
</li>
<li><strong>进入</strong>临界区之前检查标志是否可用</li>
<li><ul>
<li>若为不可用状态：进程在临界区之外等待</li>
</ul>
</li>
<li><ul>
<li>若为可用状态：访问临界资源，且将标志修改为不可用</li>
</ul>
</li>
<li><strong>退出</strong>临界区时将标志修改为可用状态</li>
</ul>
<h2 id="5-同步和p-v操作"><a href="#5-同步和P-V操作" class="headerlink" title="5. 同步和P-V操作"></a>5. 同步和P-V操作</h2><h3 id="51-同步和互斥的概念"><a href="#5-1-同步和互斥的概念" class="headerlink" title="5.1 同步和互斥的概念"></a>5.1 同步和互斥的概念</h3><p>互斥：多个进程由于<strong>共享了独占性资源</strong>，必须协调各进程对资源的存取顺序：确保没有任何两个或以上的进程<strong>同时进行存取操作</strong>。</p>
<ul>
<li>互斥和资源共享相关</li>
<li>资源：临界资源</li>
<li>存取操作区域：临界区域</li>
</ul>
<p>同步：若干<strong>合作进程</strong>为了完成一个共同的任务，需要相互协调运行步伐，一个进程<strong>开始某个操作</strong>之前必须要求另一个进程<strong>已经完成</strong>某个操作，否则前面的进程只能<strong>等待</strong></p>
<h3 id="52-p-v操作概念"><a href="#5-2-P-V操作概念" class="headerlink" title="5.2 P-V操作概念"></a>5.2 P-V操作概念</h3><p>信号灯的概念：是一种卓有成效的<strong>进程同步机制</strong>。</p>
<p>进程在运行过程中<strong>受信号灯的状态控制</strong>，并能<strong>改变信号灯状态</strong></p>
<ul>
<li>进程受控制：信号灯的状态可以<strong>阻塞</strong>或<strong>唤醒</strong>进程</li>
<li>改变信号灯：信号灯的<strong>状态</strong>可以被进程<strong>改变</strong></li>
</ul>
<h3 id="53-p-v操作解决互斥问题"><a href="#5-3-P-V操作解决互斥问题" class="headerlink" title="5.3 P-V操作解决互斥问题"></a>5.3 P-V操作解决互斥问题</h3><p><strong>实质是实现对临界区的互斥访问</strong>，允许最多1个进程处于临界区</p>
<p><code>mutex=1</code><br>应用过程：</p>
<ul>
<li>进入临界区之前先执行P操作  （上锁）</li>
<li>离开临界区之后再执行V操作  （开锁）</li>
</ul>
<h3 id="54-p-v操作解决同步问题"><a href="#5-4-P-V操作解决同步问题" class="headerlink" title="5.4 P-V操作解决同步问题"></a>5.4 P-V操作解决同步问题</h3><p>同步机制实质：</p>
<ul>
<li>运行条件不满足时，能让进程<strong>暂停</strong></li>
<li>运行条件满足时，能让进程立即<strong>继续</strong></li>
</ul>
<p>P-V操作应用于进程同步的基本思路</p>
<ul>
<li>暂停当前进程：在<strong>关键操作之前</strong>执行<strong>P</strong>操作</li>
<li><ul>
<li>必要时可暂停</li>
</ul>
</li>
<li>继续进程：在<strong>关键操作之后</strong>执行<strong>V</strong>操作</li>
<li><ul>
<li>必要时唤醒合作进程</li>
</ul>
</li>
<li>定义<strong>有意义</strong>的信号量<strong>S</strong>，并设置合适的<strong>初值</strong></li>
<li><ul>
<li>信号量S能明确的表示<strong>运行条件</strong></li>
</ul>
</li>
</ul>
<h3 id="55-经典同步问题"><a href="#5-5-经典同步问题" class="headerlink" title="5.5 经典同步问题"></a>5.5 经典同步问题</h3><p>生产者和消费者问题：一群<strong>生产者</strong>向一群<strong>消费者</strong>提供<strong>产品（数据）</strong>，共享缓冲区。</p>
<h2 id="6-windows和linux同步机制"><a href="#6-Windows和Linux同步机制" class="headerlink" title="6. Windows和Linux同步机制"></a>6. Windows和Linux同步机制</h2><h2 id="7-进程通信"><a href="#7-进程通信" class="headerlink" title="7. 进程通信"></a>7. 进程通信</h2><h3 id="71-匿名管道通信"><a href="#7-1-匿名管道通信" class="headerlink" title="7.1 匿名管道通信"></a>7.1 匿名管道通信</h3><p><strong>管道定义(pipe)：</strong>管道是进程间的一种通信机制。一个进程（A）可以通过管道把数据传输给另一个进程（B）。A向管道输入数据，B从管道读取数据。<br>A -&gt; (输入数据)-&gt; 管道 -&gt; (读取数据) -&gt; B</p>
<h3 id="linux信号通信"><a href="#Linux信号通信" class="headerlink" title="Linux信号通信"></a>Linux信号通信</h3><p>信号的概念：</p>
<ul>
<li>信号是Linux进程间一种重要的<strong>通信机制</strong></li>
<li>信号是向进程发送的<strong>一个通知</strong>，通知某个事件已发送</li>
<li>收到信号的进程可以<strong>立即执行</strong>指定的操作</li>
<li>信号的发出可以是进程，也可以是系统（含硬件）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">语法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-15 16:45:38 / 修改时间：16:56:16" itemprop="dateCreated datePublished" datetime="2022-03-15T16:45:38+08:00">2022-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>306</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="语法分析器功能"><a href="#语法分析器功能" class="headerlink" title="语法分析器功能"></a>语法分析器功能</h2><p>在<strong>词法分析</strong>出的单词符号串基础上分析并判别程序的结构<strong>是否符合语法规则</strong></p>
<h2 id="语法分析器分类"><a href="#语法分析器分类" class="headerlink" title="语法分析器分类"></a>语法分析器分类</h2><p>可分为<strong>自上而下分析法</strong>和<strong>自下而上分析法</strong>。</p>
<p>程序 -&gt; 下<br>语言 -&gt; 开始符<br>文法 -&gt; 上</p>
<p>自上而下分析：<strong>是从文法的开始符号出发，试图推导出句子。</strong> 它要解决的关键问题是在对某一个非终结符进行推导时，选择以它为左部的多个产生式的中的哪一个。 <strong><em>推导</em></strong></p>
<p>自下而上分析：<strong>是从输入符号串出发，试图归约到文法的开始符号。</strong> 分析过程中，每次选择与某个产生式右部符号串相同的一个子串进行归约。它要解决的关键问题是如何确定一个可归约的子串。 <strong><em>归约</em></strong></p>
<h2 id="自上而下分析法"><a href="#自上而下分析法" class="headerlink" title="自上而下分析法"></a>自上而下分析法</h2><p>问题：</p>
<ol>
<li><strong>回溯问题</strong></li>
<li>虚假匹配问题</li>
<li>最终报告分析不成功，难于知道输入的语法具体错误在哪</li>
<li></li>
<li><h2 id="自下而上分析法"><a href="#自下而上分析法" class="headerlink" title="自下而上分析法"></a>自下而上分析法</h2></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/" class="post-title-link" itemprop="url">操作系统用户界面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-14 16:28:31" itemprop="dateCreated datePublished" datetime="2022-03-14T16:28:31+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-15 20:05:42" itemprop="dateModified" datetime="2022-03-15T20:05:42+08:00">2022-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>856</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h2><h3 id="bios"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>实模式（实地址模式 ，REAL MODE）:</p>
<ul>
<li>程序按照8086寻址方法访问0h~FFFFFh(1MB)空间</li>
<li>寻址方式：物理地址（20位）&#x3D; 段地址 ：偏移地址</li>
<li>CPU单任务运行</li>
</ul>
<p>保护模式（内存保护模式，PROTECT MODE）</p>
<ul>
<li>寻址方式：段</li>
<li>虚拟地址，进程，封闭空间</li>
<li>应用程序和操作系统的运行环境都被<strong>保护</strong></li>
<li>CPU支持多任务</li>
</ul>
<p>实模式存取的1M空间：</p>
<ul>
<li>前面640K：00000~9FFFF 基本内存</li>
<li>中间128K：A0000~BFFFF 显卡显存</li>
<li>末尾256K：C0000~FFFFF <strong>BIOS</strong></li>
<li><ul>
<li>C0000~C7FFF:显示卡BIOS</li>
</ul>
</li>
<li><ul>
<li>C8000~CBFFF:IDE控制器BIOS</li>
</ul>
</li>
<li><ul>
<li>F0000~FFFFF：最后64KB，<strong>系统BIOS</strong><h2 id="操作系统生成"><a href="#操作系统生成" class="headerlink" title="操作系统生成"></a>操作系统生成</h2>满足特定硬件环境和用户需要，<strong>组装</strong>和<strong>构建</strong>操作系统过程</li>
</ul>
</li>
</ul>
<p>操作系统生成的主要步骤</p>
<ul>
<li>根据硬件环境&#x2F;用户要求配置功能模块和构造参数</li>
<li><strong>构建OS的映像</strong></li>
</ul>
<p>操作系统的生成前提：</p>
<ul>
<li>操作系统有可拆装模块构成</li>
<li>有交互式工具</li>
<li>有映像构建（build）工具<h2 id="操作系统用户界面"><a href="#操作系统用户界面" class="headerlink" title="操作系统用户界面"></a>操作系统用户界面</h2><h3 id="用户界面的概念"><a href="#用户界面的概念" class="headerlink" title="用户界面的概念"></a>用户界面的概念</h3>定义：OS提供给用户操作计算机的机制，又称用户接口</li>
</ul>
<p>分类：</p>
<ul>
<li>操作界面</li>
<li><ul>
<li><strong>图形用户接口</strong>（GUI，Graphic User Interface）：窗口，图标，菜单，按钮，鼠标（消息，事件）</li>
</ul>
</li>
<li><ul>
<li><strong>键盘命令</strong>（COMMAND）：在控制台环境下接受键盘输入的命令，分为普通命令、批处理程序、shell</li>
</ul>
</li>
<li>系统调用（System Call,系统功能调用，程序界面）</li>
</ul>
<h3 id="shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h3><p>脚本（Script）通过类似程序的方式执行具有一定逻辑顺序的<strong>命令序列</strong>完成较复杂的功能和人机交互。</p>
<ul>
<li>脚本程序保存在<strong>文本文件</strong>中</li>
<li>脚本程序是Shell命令语句的集合</li>
<li>Shell脚本程序由Shell环境解释执行</li>
<li>执行Shell脚本文件需要具有可执行属性（x）.</li>
<li><ul>
<li><code>Chmod +x MyScript.sh</code></li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>定义：操作系统<strong>内核</strong>为应用程序提供的<strong>服务&#x2F;函数</strong></p>
<p>特点：</p>
<ul>
<li>一般涉及和性资源或硬件的操作，</li>
<li>且运行于<strong>核态</strong></li>
<li>每个系统调用具有唯一编号：ID</li>
<li>调用程序过程会产生<strong>中断</strong>:自愿中断</li>
<li>高级程序语言中使用隐式的系统调用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">操作系统的逻辑结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-14 10:53:36" itemprop="dateCreated datePublished" datetime="2022-03-14T10:53:36+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-13 19:01:54" itemprop="dateModified" datetime="2023-04-13T19:01:54+08:00">2023-04-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>618</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>操作系统的逻辑结构指<strong>OS的设计和实现思路</strong>,可分为以下三种：</p>
<ol>
<li><p>整体式结构：以<strong>模块</strong>为基本单位</p>
<ul>
<li>特点：</li>
<li><ul>
<li>模块设计、编码和调试独立</li>
</ul>
</li>
<li><ul>
<li>模块调用自由</li>
</ul>
</li>
<li><ul>
<li>魔魁啊通信多以<strong>全局变量</strong>形式完成</li>
</ul>
</li>
<li>缺点：</li>
<li><ul>
<li>信息传递随意，维护和更新困难</li>
</ul>
</li>
</ul>
</li>
<li><p>层次式结构：例如TCP&#x2F;IP协议栈。p所有功能模块按照<strong>调用次序</strong>排成若干层，相邻层间只有<strong>单向依赖</strong>或<strong>单向调用</strong></p>
</li>
</ol>
  <img src="/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/2022-03-14-11-03-53.png" alt="操作系统的层次结构" style="zoom: 67%;">

<ol start="3">
<li>微内核结构（客户&#x2F;服务器结构）：操作系统 &#x3D; 微内核 + 核外服务器</li>
</ol>
<ul>
<li>微内核:足够小，提供OS最基本的核心功能和服务</li>
<li>核外服务器：完成OS的绝大部分服务器功能</li>
</ul>
<h2 id="cpu的态"><a href="#CPU的态" class="headerlink" title="CPU的态"></a>CPU的态</h2><p>CPU的工作状态，对资源和指令使用权限的描述</p>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>不能被用户随意的使用，只能由CPU亲自使用</p>
<ul>
<li>由用户态转到核态</li>
<li>LGDT&#x2F;LIDT：装载特殊寄存器</li>
<li>CLTS：清除任务开关标志</li>
<li>STI&#x2F;CTI：允许和禁止中断</li>
<li>HALT：停止CPU的工作</li>
<li>从核态转回用户态</li>
</ul>
<h3 id="态的分类"><a href="#态的分类" class="headerlink" title="态的分类"></a>态的分类</h3><p>核态（Kernel mode)</p>
<ul>
<li>能够访问所有资源和执行所有指令</li>
<li>管理程序OS内核</li>
</ul>
<p>用户态（User mode）</p>
<ul>
<li>仅能访问部分资源，其他资源受限</li>
<li>用户程序</li>
</ul>
<p>管态（superVisor mode）</p>
<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p><strong>中断，指CPU对突发的外部事件的反应过程或机制</strong>。CPU收到<strong>外部信号</strong>（中断信号）后，停止当前工作，专区专利该事件，处理完毕后回到原来工作的<strong>中断处</strong>（断点）继续原来的工作。</p>
<p><strong>引入中断的目的：</strong></p>
<ul>
<li>实现并发活动</li>
<li>实现实时处理</li>
<li>故障自动处理</li>
</ul>
<p><strong>中断响应的实质：</strong></p>
<ul>
<li>交换指令执行地址</li>
<li>交换CPU的态</li>
<li>工作</li>
<li><ul>
<li>现场保护和恢复</li>
</ul>
</li>
<li><ul>
<li>参数传递（通信）</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/09/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/" class="post-title-link" itemprop="url">面向对象的基本特征</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 19:03:38" itemprop="dateCreated datePublished" datetime="2022-03-09T19:03:38+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 19:24:05" itemprop="dateModified" datetime="2022-03-21T19:24:05+08:00">2022-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java中的面向对象基本特征是：封装、继承、多态</p>
<h2 id="封装encapsulation"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><p>包、访问控制符</p>
<h3 id="11-包"><a href="#1-1-包" class="headerlink" title="1.1 包"></a>1.1 包</h3><ol>
<li>包的封装：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pack.sonpack. </span><br></pre></td></tr></table></figure>
将该文件下的类放入pack.sonpack包</li>
<li>包的使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pack.sonpack.*</span><br></pre></td></tr></table></figure>
即引用pack.sonpack下所有的类。<strong>引入包时并不会将子包中的类一起引入</strong></li>
</ol>
<h3 id="12-访问控制符"><a href="#1-2-访问控制符" class="headerlink" title="1.2 访问控制符"></a>1.2 访问控制符</h3><p><strong>private:</strong> 仅能在类内访问<br><strong>default:</strong> private + 同一个包内访问<br><strong>protected:</strong> default + 包外子类访问<br><strong>public:</strong> protected + 包外非子类访问</p>
<h2 id="继承inherition"><a href="#继承（inherition）" class="headerlink" title="继承（inherition）"></a>继承（inherition）</h2><p>C++： class 子类 : [访问控制符] 父类 {}<br>Java: class 子类 extends 父类 {}</p>
<p>重写的作用：针对某些子类进行个性化设计<br>继承的本质：</p>
<ul>
<li>从现象上看，子类实例化之前，系统为这个子类对象单独实例化一个相应的父类对象。（每个子类构造函数调用之前，父类构造函数都会自动调用）</li>
<li>从本质上：子类和父类就是一种组合关系，只是底层用继承的编译器使得其使用起来更加方便</li>
</ul>
<p>组合关系，从强到弱：<br>最强：继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FontDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>父类中的非私有成员都可以在子类全范围内重用。</p>
<p>次之：成员级别组合，A类定义为B类的成员，A和B的生命周期相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    B(<span class="type">int</span> w)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A(<span class="type">int</span> w)&#123;</span><br><span class="line">        <span class="built_in">super</span>(w);    <span class="comment">/*必须写在第一行*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态polymorphism"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>静态多态性：重载（Overload）。<strong>同一个</strong>函数名称，在<strong>不同实参</strong>传入情况下，呈现<strong>不同功能</strong><br>静态：一个函数名称，但是还是要编写多个函数体</p>
<p>动态多态性：<strong>父类引用可以指向子类对象</strong>，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dialog show&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FontDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Dialog d=<span class="keyword">new</span> <span class="title class_">FontDialog</span>();</span><br><span class="line">        <span class="comment">//C++: Dialog *d=new FontDialog();</span></span><br><span class="line">        <span class="comment">//C++: 父类指针指向子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性质</strong>：父类引用调用重写成员时，调用的是重写子类成员</p>
<p><strong>推论</strong>：</p>
<ol>
<li><p>函数定义父类形参，以子类对象作为实参传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Dialog d)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">fun(<span class="keyword">new</span> <span class="title class_">FontDialog</span>())</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数定义返回父类形参，以子类对象实际返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">Dialog <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FontDialog</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Dialog d=fun();</span><br></pre></td></tr></table></figure>
<p>多态性体现在：一个父类引用，在不同子类对象被指向的情况下，完成相应子类的功能。</p>
</li>
</ol>
<p>该思想是软件支持“<strong>不修改源代码的情况下，能够二次开发</strong>”以及“<strong>模块可拼装</strong>”的基础。将两个业务类的关系变远，这就叫做软件工程中的“低耦合”。</p>
<h3 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h3><p>抽象函数：在函数签名增加<code>abstract</code>关键字，该函数原则上要被重写，（可以理解为用来<strong>规范编程</strong>，确保某些方法必须要重写）。</p>
<ol>
<li>含有抽象函数的类，叫<strong>抽象类</strong>，用<code>abstract</code>来修饰</li>
<li>抽象函数必须被子类重写，除非该子类也是个抽象类</li>
<li>抽象函数没有函数体（类似于C++中的纯虚函数）</li>
<li>抽象类<strong>不能被实例化</strong></li>
</ol>
<p>练习：</p>
<ol>
<li>抽象类中可否有普通函数？<strong>可以</strong></li>
<li>抽象类中可否写构造函数？<strong>可以</strong></li>
<li>抽象类不能被实例化，那它的构造函数和普通函数有什么用？ <strong>构造函数可以在子类中初始化某些变量；普通函数可以被子类重用</strong></li>
<li>抽象函数必须被重写吗？ <strong>不一定，如果子类也是个抽象类的话</strong></li>
</ol>
<blockquote>
<p>抽象类、抽象函数是一种：<strong>标准化手段</strong> 。</p>
</blockquote>
<h3 id="接口interface"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><p>interface和抽象类类似，只不过<strong>它里面所有函数只能是抽象函数，所有的变量只能是常量</strong>。</p>
<p>性质：</p>
<ol>
<li>接口中所有的函数都说抽象函数，变量只能是常量。<code>abstract</code>可以省略</li>
<li>接口中所有的成员的都是<code>public</code>。所以<code>public</code>也可以省略</li>
<li>接口中所有的变量都是常量,并且是静态常量</li>
<li>一个类最多只能继承1个抽象类，但是可以实现（implements）多个接口，用逗号隔开。</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul>
<li>在类前面加final，该类不能有子类</li>
<li>成员函数前加final，该函数不能被重写</li>
<li>成员变量前加final，为常量，必须事先赋值，不能再次赋值</li>
</ul>
<h2 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h2><p>在Java中定义一个类时，如果没有用extends明确标明直接父类，那么该类默认继承object类。</p>
<p><strong>Java中任何一个类都是object的子类</strong></p>
<p>该类有两个小作用：</p>
<ol>
<li>object类中，有一个toString方法，可以给子类一个以字符串展示的机会</li>
<li>object类中，有一个equals方法，可以给予子类对象一个可以比较的机会<ul>
<li>两个对象除非，指向同一个内存，否则，&#x3D;&#x3D;判断，为false </li>
<li>若要判断两个对象内容是否相等，应该使用equals方法</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 13:58:09" itemprop="dateCreated datePublished" datetime="2022-03-08T13:58:09+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-11 15:39:59" itemprop="dateModified" datetime="2022-03-11T15:39:59+08:00">2022-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><ol>
<li><strong>位置</strong>： 物理层是网络体系结构中的最底层</li>
<li><strong>功能</strong>：规定如何再连接各个计算机之间比特流的传输</li>
<li></li>
</ol>
<h3 id="物理层常用标准"><a href="#物理层常用标准" class="headerlink" title="物理层常用标准"></a>物理层常用标准</h3><p><strong>点对点通信线路</strong><br><strong>广播通信线路</strong>：一条公共通信线路连接多个节点</p>
<h2 id="物理层数据通信"><a href="#物理层数据通信" class="headerlink" title="物理层数据通信"></a>物理层数据通信</h2><h3 id="波特率和比特率之间的关系"><a href="#波特率和比特率之间的关系" class="headerlink" title="波特率和比特率之间的关系"></a>波特率和比特率之间的关系</h3><h3 id="信道的最大数据传输速率"><a href="#信道的最大数据传输速率" class="headerlink" title="信道的最大数据传输速率"></a>信道的最大数据传输速率</h3><p>无噪声有限带宽信道的最大数据传输率公式</p>
<p>奈奎斯特定理</p>
<ul>
<li>最大数据传输率 &#x3D; 2H log<sub>2</sub>V (bps)</li>
<li>H指带宽</li>
</ul>
<p>随机噪声出现的大小用信噪比（信号功率S与噪声功率N之比）来衡量， 10log<sub>10</sub>S&#x2F;N,单位分贝</p>
<p>香农定理</p>
<ul>
<li>带宽为H赫兹，信噪比为S&#x2F;N的任意信道的最大数据传输率为: Hlog<sub>2</sub>(1+S&#x2F;N)（bps）</li>
<li>此式由信息论获得，具有普遍意义</li>
</ul>
<h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><p>源点 -&gt; 发送器 -&gt; 传输系统 -&gt; 接收器 -&gt; 目标<br>PC   -&gt; 调制解调器 -&gt; 公用电话网 -&gt; 调制解调器 -&gt; PC机<br>数字比特流  -&gt;  模拟信号   -&gt;   模拟信号   -&gt;  数字比特流</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>串行和并行传输</p>
<ul>
<li>串行传输： 指数据在一个信道上按位依次传输的方式</li>
<li><ul>
<li>所需线路少，投资省，线路利用率搞</li>
</ul>
</li>
<li><ul>
<li>收发之间，适合远距离传输</li>
</ul>
</li>
<li>并行传输：</li>
<li>- </li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>按照数据信号在信道上的<strong>传送方向与时间</strong>的关系可分为：单工（类似广播）、半双工（一方占用信道）、全双工</p>
<p>按照<strong>发&#x2F;收连两端实现同步</strong>的方法，传输方式可分为两类： 异步传输和同步传输。</p>
<ul>
<li>异步：发送器和接收器的时钟不同步</li>
<li>同步：发送器和接收器的时钟是同步的</li>
</ul>
<h3 id="数据编码技术"><a href="#数据编码技术" class="headerlink" title="数据编码技术"></a>数据编码技术</h3><p>研究数据在信号传输过程中如何进行编码（变换）<br>常用的几种编码方式：</p>
<ol>
<li>不归零制码（NRZ: Non-Return to Zero）</li>
</ol>
<ul>
<li>原理</li>
</ul>
<ol start="2">
<li>曼彻斯特码（Manchester）,也称相位编码。分逢1跳变和逢0跳变。</li>
<li>差分曼彻斯特码（Diffential Manchster）</li>
</ol>
<h3 id="频带传输"><a href="#频带传输" class="headerlink" title="频带传输"></a>频带传输</h3><p>三种调制技术：载波Asin(wt+)的三个特性幅度、频率、相位</p>
<ul>
<li>调幅(ASK)：</li>
<li>调频(FSK):</li>
<li>调相(PSK):</li>
</ul>
<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>传输介质是指发送器与接收器之间的物理通路可分为两大类：</p>
<ul>
<li>导引型传输介质：指电磁波被导向沿着某一媒体传播，包括</li>
<li><ul>
<li>双绞线、同轴电缆</li>
</ul>
</li>
<li>非导引型传输介质：并不沿着某一确定通道传播</li>
</ul>
<h2 id="无线与卫星通信"><a href="#无线与卫星通信" class="headerlink" title="无线与卫星通信"></a>无线与卫星通信</h2><h3 id="无线通信的基本概念"><a href="#无线通信的基本概念" class="headerlink" title="无线通信的基本概念"></a>无线通信的基本概念</h3><h3 id="无线通信系统分类"><a href="#无线通信系统分类" class="headerlink" title="无线通信系统分类"></a>无线通信系统分类</h3><h3 id="卫星通信的基本概念"><a href="#卫星通信的基本概念" class="headerlink" title="卫星通信的基本概念"></a>卫星通信的基本概念</h3><p>卫星通信的基本特点<br>传播时延长</p>
<h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><p>信道资源是有限的，实际网络中，多对用户往往需要利用信道资源传输信息，不同的信号同时在同一信道中传输会产生严重的相互干扰，导致传输失败<br><strong>复用</strong>：技术的目的是：允许用户使用一个共享信道进行通信，避免相互干扰，降低成本，提高利用率。<br><img src="/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/2022-03-11-15-39-02.png" alt="复用示意图"></p>
<h3 id="频分复用fdm"><a href="#频分复用（FDM）" class="headerlink" title="频分复用（FDM）"></a>频分复用（FDM）</h3><p>频分复用是一种讲多路基带信号调制到不同</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hestar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hestar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 13:42:54" itemprop="dateCreated datePublished" datetime="2022-03-08T13:42:54+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-22 14:29:21" itemprop="dateModified" datetime="2022-03-22T14:29:21+08:00">2022-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>790</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据链路层在协议栈中的位置<br>向下：：<br>向上：</p>
<p>功能：</p>
<ul>
<li><strong>封装成帧（Framing）</strong>：将比特流划分成“帧”的主要目的是为了检测和纠正物理层在比特传输中的可能出现的错误，数据链路层功能需借助“帧”的各个域来实现</li>
<li><strong>差错控制（Error Control）</strong>：要处理传输中出现的差错，如位错误、丢失</li>
<li><strong>流量控制（FLow Control）</strong>：确保发送方的发送速率，不大于接收方的处理速率</li>
</ul>
<p>服务：</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>关键问题： 接收方必须能从物理层接受的比特流中明确区分出一帧的开始和结束。这个问题被称为<strong>帧同步或帧界定</strong></p>
<ul>
<li>选择何种<strong>定界符</strong>，定界符出现在数据部分如何处理。</li>
</ul>
<p>封装成帧方式：</p>
<ol>
<li><strong>字节计数法</strong>：帧开始的数，表示该帧有多长。<strong>仅能用于无差错传输的情形</strong>，不健壮，很少使用。<br> <strong>3</strong> 1 2 3 <strong>4</strong> 1234</li>
<li><strong>带字符填充的定界符法</strong>：定界符（FLAG），一个特殊的字节，比如<code>0111 1110</code>，即<code>0x7e</code>，<strong>用于区分前后两个不同的帧</strong>。<ul>
<li>发送方：检查有效载荷，进行字节填充，若在有效荷载中<strong>发现定界符</strong>，则在前加入<strong>转义字节</strong></li>
<li>接收方：去除头部的Flag后，对有效荷载进行检测，<strong>收到ESC转义字节后</strong>，将后一字节<strong>无条件成为有效载荷</strong>。找到真正的定界符后，进行处理，得到处理后的真正有效荷载。</li>
</ul>
</li>
<li><strong>带比特填充的定界符法</strong>：<ul>
<li>发送方检查有效载荷，若在有效载荷中出现连续5个1，则直接插入一个0比特</li>
<li>接收方处理，若出现连续的<strong>5个1</strong>，若下一比特为0，则为有效载荷，直接丢弃0比特；若下一比特为1，则为定界符，一帧结束</li>
</ul>
</li>
</ol>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p><strong>信道的噪声导致数据传输问题</strong></p>
<ul>
<li>差错：数据发生错误</li>
<li></li>
<li>丢失：接收方未收到</li>
<li>乱序：先发后到，后发先到</li>
<li>重复，一次发送，多次接受</li>
</ul>
<p><strong>解决方案</strong>：差错检测与纠正，确认重传</p>
<h3 id="如何解决信道传输差错问题"><a href="#如何解决信道传输差错问题：" class="headerlink" title="如何解决信道传输差错问题："></a>如何解决信道传输差错问题：</h3><ul>
<li>通常采用<strong>增加冗余信息</strong>（或称校验信息）的策略</li>
</ul>
<p>目标：保证一定差错检测和纠错能力的前提下，如何减少冗余信息</p>
<h3 id="差错检测和纠正概述"><a href="#差错检测和纠正概述" class="headerlink" title="差错检测和纠正概述"></a>差错检测和纠正概述</h3><p>检错码</p>
<ul>
<li>在被发送的数据块中，包含一些荣誉信息，但这些信息只能是接收方</li>
</ul>
<h2 id="基本的数据链路层协议"><a href="#基本的数据链路层协议" class="headerlink" title="基本的数据链路层协议"></a>基本的数据链路层协议</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hestar</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hestar</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">25k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
